(define (minus? expr)
  (and (list? expr)
       (= (length expr) 2)
       (equal? (list-ref expr 0) '-)))

(define (const-prod? expr)
  (and (list? expr)
       (= (length expr) 3)
       (number? (cadr expr))
       (equal? (list-ref expr 0) '*)))

(define (u*w*v? expr)
  (and (= (length expr) 5)
       (equal? (car expr) '*)))

(define (f*g? expr)
  (and (= (length expr) 4)
       (equal? (car expr) '*)))

(define (x^n? expr)
  (and (list? expr)
       (= (length expr) 3)
       (equal? (list-ref expr 0) 'expt)
       (number? (list-ref expr 2))
       (or (number? (list-ref expr 1))
           (list? (list-ref expr 1))
           (symbol? (list-ref expr 1)))))

(define (n^x? expr)
  (and (list? expr)
       (= (length expr) 3)
       (equal? (list-ref expr 0) 'expt)
       (number? (list-ref expr 1))
       (or (number? (list-ref expr 2))
           (list? (list-ref expr 2))
           (symbol? (list-ref expr 2)))))

(define (sum? expr)
  (and (list? expr)
       (= (length expr) 3)
       (or
        (equal? (list-ref expr 0) '-)
        (equal? (list-ref expr 0) '+))))

(define (trigo? expr)
  (and (list? expr)
       (= (length expr) 2)
       (or (equal? (list-ref expr 0) 'sin)
           (equal? (list-ref expr 0) 'cos)
           (equal? (list-ref expr 0) 'tan))))

(define (e^x? expr)
  (equal? (list-ref expr 0) 'exp))

(define (ln? expr)
  (equal? (car expr) 'log))

(define (n/x? expr)
  (and (number? (cadr expr))
       (equal? (car expr) '/)))

(define (u/v? expr)
  (and (not (number? (cadr expr)))
       (equal? (car expr) '/)))


(define (der-minus expr)
  (define a (derivative (list-ref expr 1)))
  (- a))

(define (der-prod-num expr)
  (define a (list-ref expr 1))
  (define b (derivative (list-ref expr 2)))
  (if (and (number? a) (number? b))
      (* a b)
      `(* ,a ,b)))

(define (der-sum expr)
  (define a (derivative (list-ref expr 1)))
  (define b (derivative (list-ref expr 2)))
  (if (equal? (list-ref expr 0) '-)
      (if (and (number? a) (number? b))
          (- a b)
          `(- ,a ,b))
      (if (and (number? a) (number? b))
          (+ a b)
          `(+ ,a ,b))))

(define (der-x^n expr)
  (define x (list-ref expr 1))
  (define n (list-ref expr 2))
  (define n-1 (- (list-ref expr 2) 1))
  `(* ,n (expt ,x ,n-1)))

(define (der-n^x expr)
  (define x (list-ref expr 2))
  (define n (list-ref expr 1))
  `(* (expt ,n ,x) (log ,n)))

(define (der-trigo expr)
  (define f (list-ref expr 0))
  (define x (list-ref expr 1))
  (or (and (equal? f 'sin)
           `(* ,(derivative x) (cos ,x)))
      (and (equal? f 'cos)
           `(- (* ,(derivative x) (sin ,x))))))

(define (der-e^x expr)
  (define f expr)
  (define dx (derivative (list-ref expr 1)))
  `(* ,dx ,f))

(define (der-ln expr)
  (define x (cadr expr))
  `(* ,(derivative x) (/ 1 ,x)))

(define (der-n/x expr)
  (define n (cadr expr))
  (define x (caddr expr))
  (or
   (and (x^n? x)
        `( * (- ,(caddr x))
             (/ ,n (expt ,(cadr x)
                         (+ ,(caddr x) 1)))))
   (and (const-prod? x)
        `( * (- ,(caddr (caddr x)))
             (/ ,n ( * ,(cadr x)
                       (expt ,(cadr (caddr x))
                             (+ ,(caddr (caddr x)) 1))))))
   `(- (/ ,n (expt ,x 2)))))

(define (der-u*w*v expr)
  (define (loop new-expr)
    (define u (cadr new-expr))
    (define w (caddr new-expr))
    (define v (cadddr new-expr))
    `(+ (* ,(derivative u) ,w ,v)
        (* ,u ,(derivative w) ,v)
        (* ,u ,w ,(derivative v))))
  `(* ,(cadr expr) ,(loop (cdr expr))))

(define (der-f*g expr)
  (define u (cadr expr))
  (define w (caddr expr))
  (define v (cadddr expr))
  `(+ (* ,(derivative u) ,w ,v)
      (* ,u ,(derivative w) ,v)
      (* ,u ,w ,(derivative v))))

(define (der-u/v expr)
  (define u (cadr expr))
  (define v (caddr expr))
  `(/ (- (* ,(derivative u) ,v)
         (* ,u ,(derivative v)))
      (expt v 2)))

(define (der-else expr)
  (define f (cadr expr))
  (define g (caddr expr))
  `(+ (* ,(derivative f) ,g) (* ,f ,(derivative g))))

(define (derivative expr)
  (if (not (list? expr)) (set! expr (list expr)))
  (cond
    ((number? (car expr)) 0)
    ((equal? (car expr) 'x) 1)
    ((equal? (car expr) '-x) -1)
    ((minus? expr) (der-minus expr))
    ((and (const-prod? expr) (number? (list-ref expr 1))) (der-prod-num expr))
    ((sum? expr) (der-sum expr))
    ((x^n? expr) (der-x^n expr))
    ((n^x? expr) (der-n^x expr))
    ((trigo? expr) (der-trigo expr))
    ((e^x? expr) (der-e^x expr))
    ((ln? expr) (der-ln expr))
    ((n/x? expr) (der-n/x expr))
    ((f*g? expr) (der-f*g expr))
    ((u*w*v? expr) (der-u*w*v expr))
    (else
     (der-else expr))))

#| Ачивки: |#

(define (simplify expr)
  (if (not (list? expr))
      expr
      (if (equal? '* (car expr))
          (let loop ((expr (cdr expr))
                     (ans (list)))
            (if (null? expr)
                (if (null? ans)
                    1
                    (if (null? (cdr ans))
                        (car ans)
                        (cons '* (reverse ans))))
           
                (let ((current (simplify (car expr))))
                  (if (equal? current 0)
                      0
                      (if (equal? current 1)
                          (loop (cdr expr) ans)
                          (loop (cdr expr) (cons current ans)))))))
          (if (equal? '+ (car expr))
              (let loop ((expr (cdr expr))
                         (ans (list)))
                (if (null? expr)
                    (if (null? ans)
                        0
                        (if (null? (cdr ans))
                            (car ans)
                            (cons '+ (reverse ans))))
                    (let ((current (simplify (car expr))))
                      (if (equal? current 0)
                          (loop (cdr expr) ans)
                          (loop (cdr expr) (cons current ans))))))
              (let loop ((expr expr)
                         (ans '()))
                (if (null? expr)
                    (reverse ans)
                    (loop (cdr expr) (cons (simplify (car expr)) ans))))))))

(define-syntax flatten
  (syntax-rules ()
    ((_ ((current ...) nexties ...) term ...)
     (flatten (current ... nexties ...) term ...))
    ((_ (current next ...) term ...)
     (flatten (next ...) term ... current))
    ((_ () term ...)
     (term ...))))

(define-syntax extract-pointer
  (syntax-rules ()
    ((_ (start (case ...) nexties ...))
     (extract-pointer (start case ... nexties ...)))
    ((_ (start nexties ...))
     (if (eq? 'x 'start)
         start
         (extract-pointer (nexties ...))))
    ((_ case ...) #f)))

(define-syntax mderivative
  (syntax-rules ()
    ((_ expr)
     (eval `((lambda (x) 
               ,(derivative 'expr)) ,(extract-pointer expr)) (interaction-environment)))))
